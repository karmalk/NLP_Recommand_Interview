# Python 面试题

tags: python

---



## 1. 垃圾回收机制

**引用计数为主，分代收集为辅。**在 python 中，如果一个对象的引用数为 0， python 虚拟机就会回收这个对象的内存。

- 导致引用计数 +1 的情况：

  > - 对象被创建： a = classname()
  > - 对象被引用： b = a
  > - 对象被作为参数，传入到一个函数中： func(a)
  > - 对象作为一个元素，存储在容器内： list_name = [a, a]

- 导致引用计数 -1 的情况：

  > - 对象的别名被显式销毁， 如： del a 
  > - 对象的别名被赋予新的对象，如：a = other_class()
  > - 一个对象离开它的作用域，如函数执行完毕时，func 函数中的局部变量
  > - 对象所在的容器被销毁，或从容器中删除对象

**循环引用导致内存泄漏**

```
c1=ClassA() # 内存 1 引用计数 +1 = 1
c2=ClassA() # 内存 2 引用计数 +1 = 1
c1.t=c2  #  内存 2 引用计数 +1 = 2
c2.t=c1  #  内存 1 引用计数 +1 = 2
del c1  # 内存 1 引用计数 -1 = 1
del c2  # 内存 2 引用计数 -1 = 1
```

如上文描述，由于**循环引用**，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

**垃圾回收机制模块： gc**

## 2,Python中list底层代码是怎么实现的

在CPython中，列表被实现为长度可变的数组(动态数组，类似于C++ STL中的vector)

**Python中的list是一个动态数组，它储存在一个连续的内存块中，随机存取的时间复杂度是O(1),但插入和删除时会造成内存块的移动，时间复杂度是O(N),同时，当数组中内存不够时，会重新申请一块内存空间并进行内存拷贝**

Python中的列表是由其他对象的引用组成的连续数组，指向这个数组的指针及其长度被保存在一个列表头结构中，这意味着每次添加或者删除一个元素时，由引用组成的数组需要该标大小(重新分配)，但是Python在创建这些数组时采用了指数过分配，所以并不是每次操作都需要改变数组的大小。

## 3,Python 迭代器和生成器的区别

